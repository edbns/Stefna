async function h(t){if(typeof t=="string"&&/^https?:\/\//i.test(t)){const r=/\.(mp4|mov|webm)$/i.test(t)?"video":"image";return{url:t,resource_type:r}}let p;if(typeof t=="string"&&t.startsWith("blob:")){const o=await(await fetch(t)).blob(),l=o.type.startsWith("image/")?o.type.split("/")[1]||"png":o.type.startsWith("video/")?o.type.split("/")[1]||"mp4":"bin";p=new File([o],`source.${l}`,{type:o.type||"application/octet-stream"})}else p=t;const u=await fetch("/.netlify/functions/cloudinary-sign",{method:"POST"}),{timestamp:c,signature:d,api_key:y,cloud_name:f,folder:n,upload_preset:a}=await u.json(),e=new FormData;e.append("file",p),e.append("timestamp",String(c)),e.append("signature",d),e.append("api_key",y),n&&e.append("folder",n),a&&e.append("upload_preset",a);const i=await fetch(`https://api.cloudinary.com/v1_1/${f}/auto/upload`,{method:"POST",body:e}),s=await i.json().catch(()=>({}));if(!i.ok)throw console.error("Cloudinary upload failed:",s),new Error("Cloudinary upload failed");const m=s.resource_type;return{url:s.secure_url,resource_type:m}}export{h as prepareSourceAsset};
