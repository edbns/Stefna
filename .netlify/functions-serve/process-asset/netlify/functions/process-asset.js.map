{
  "version": 3,
  "sources": ["../../../../../../Users/sennie/Desktop/Stefna-main/netlify/functions/process-asset.ts", "../../../../../../Users/sennie/Desktop/Stefna-main/netlify/lib/supabaseAdmin.ts", "../../../../../../Users/sennie/Desktop/Stefna-main/netlify/lib/cloudinary.ts"],
  "sourceRoot": "/var/folders/3j/nmp5dkpd4tv8j0yq8f2ln8780000gn/T/tmp-42344-2tFPvL4Ta3cQ",
  "sourcesContent": ["import { Handler } from '@netlify/functions';\nimport { supabaseAdmin } from '../lib/supabaseAdmin';\nimport { cloudinary } from '../lib/cloudinary';\nimport type { ProcessAssetPayload, ApiResult } from '../../src/lib/types';\n\n// pretend AI call\nasync function runAIMLTransform(input: ProcessAssetPayload): Promise<{ tempLocalPath?: string; finalBuffer?: Buffer; error?: string }> {\n  // Implement your provider call here and return a buffer or temp file.\n  // For now, pretend we got a buffer back:\n  return { finalBuffer: Buffer.from('fake-binary') };\n}\n\nexport const handler: Handler = async (event) => {\n  try {\n    const payload = JSON.parse(event.body || '{}') as ProcessAssetPayload;\n    if (!payload.assetId || !payload.sourcePublicId || !payload.mediaType) {\n      return resp({ ok: false, error: 'assetId, sourcePublicId, mediaType required' });\n    }\n\n    // Mark processing (optional)\n    await supabaseAdmin\n      .from('assets')\n      .update({ status: 'processing' })\n      .eq('id', payload.assetId);\n\n    const result = await runAIMLTransform(payload);\n    if (result.error) {\n      await supabaseAdmin.from('assets').update({ status: 'failed' }).eq('id', payload.assetId);\n      return resp({ ok: false, error: result.error });\n    }\n\n    // Upload to Cloudinary\n    const uploadRes = await cloudinary.uploader.upload_stream({ resource_type: payload.mediaType === 'video' ? 'video' : 'image' }, async () => {});\n\n    // Because upload_stream requires piping, provide a helper:\n    const finalPublicId = await new Promise<string>((resolve, reject) => {\n      const upload = cloudinary.uploader.upload_stream(\n        { resource_type: payload.mediaType === 'video' ? 'video' : 'image' },\n        (err, res) => {\n          if (err || !res?.public_id) return reject(err || new Error('No Cloudinary response'));\n          resolve(res.public_id);\n        }\n      );\n      // write buffer\n      if (result.finalBuffer) {\n        upload.end(result.finalBuffer);\n      } else {\n        reject(new Error('No AI output buffer'));\n      }\n    });\n\n    console.log(`[process-asset] Updating asset ${payload.assetId} with:`, {\n      status: 'ready',\n      cloudinary_public_id: finalPublicId,\n      media_type: payload.mediaType\n    });\n\n    const { error: updErr } = await supabaseAdmin\n      .from('assets')\n      .update({\n        status: 'ready',\n        cloudinary_public_id: finalPublicId,\n        media_type: payload.mediaType, // Ensure media_type is set\n      })\n      .eq('id', payload.assetId);\n\n    if (updErr) {\n      console.error(`[process-asset] DB update failed:`, updErr);\n      return resp({ ok: false, error: updErr.message });\n    }\n\n    console.log(`[process-asset] Asset ${payload.assetId} successfully updated to ready status`);\n\n    return resp({ ok: true, data: { assetId: payload.assetId, finalPublicId } });\n  } catch (e: any) {\n    return resp({ ok: false, error: e.message || 'process-asset error' });\n  }\n};\n\nfunction resp(body: ApiResult<any>) {\n  return { statusCode: body.ok ? 200 : 400, body: JSON.stringify(body) };\n}\n", "import { createClient } from '@supabase/supabase-js';\n\nexport const supabaseAdmin = createClient(\n  process.env.SUPABASE_URL!,\n  process.env.SUPABASE_SERVICE_ROLE_KEY!,\n  { auth: { persistSession: false } }\n);\n", "import { v2 as cloudinary } from 'cloudinary';\n\ncloudinary.config({\n  cloud_name: process.env.CLOUDINARY_CLOUD_NAME!,\n  api_key: process.env.CLOUDINARY_API_KEY!,\n  api_secret: process.env.CLOUDINARY_API_SECRET!,\n  secure: true,\n});\n\nexport { cloudinary };\n"],
  "mappings": "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",
  "names": ["cloudinary", "cloudinary"]
}
