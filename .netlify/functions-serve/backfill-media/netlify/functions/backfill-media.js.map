{
  "version": 3,
  "sources": ["../../../../../../Users/sennie/Desktop/Stefna-main/netlify/functions/backfill-media.ts"],
  "sourceRoot": "/var/folders/3j/nmp5dkpd4tv8j0yq8f2ln8780000gn/T/tmp-42344-D2IYFrnJH9zD",
  "sourcesContent": ["import type { Handler } from '@netlify/functions';\nimport { createClient } from '@supabase/supabase-js';\nimport { v2 as cloudinary } from 'cloudinary';\n\nconst SUPABASE_URL = process.env.SUPABASE_URL!;\nconst SUPABASE_SERVICE_ROLE_KEY = process.env.SUPABASE_SERVICE_ROLE_KEY!;\nconst MEGA_TAG = process.env.MEGA_COLLECTION_TAG ?? 'collection:mega';\n\ncloudinary.config({\n  cloud_name: process.env.CLOUDINARY_CLOUD_NAME!,\n  api_key: process.env.CLOUDINARY_API_KEY!,\n  api_secret: process.env.CLOUDINARY_API_SECRET!,\n  secure: true,\n});\n\nconst supabase = createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY);\n\ntype Body = {\n  userId: string;\n  dryRun?: boolean;\n  includeFolders?: string[];\n  includeTags?: string[];\n};\n\nfunction chunk<T>(arr: T[], n = 100) {\n  const out: T[][] = [];\n  for (let i = 0; i < arr.length; i += n) out.push(arr.slice(i, i + n));\n  return out;\n}\n\nexport const handler: Handler = async (event) => {\n  try {\n    if (event.httpMethod !== 'POST') return { statusCode: 405, body: 'Method Not Allowed' };\n\n    const body = JSON.parse(event.body || '{}') as Body;\n    const { userId, dryRun = false, includeFolders = [], includeTags = [] } = body;\n    if (!userId) return { statusCode: 400, body: JSON.stringify({ ok: false, error: 'userId required' }) };\n\n    // 1) Pull all Cloudinary assets for this user (by folder or tag)\n    const expressions: string[] = [\n      `folder=\"stefna/outputs/${userId}\"`,\n      `tags=\"user:${userId}\"`,\n      ...includeFolders.map(f => `folder=\"${f}\"`),\n      ...includeTags.map(t => `tags=\"${t}\"`),\n    ];\n    const expression = expressions.join(' OR ');\n\n    let next_cursor: string | undefined = undefined;\n    const resources: any[] = [];\n\n    do {\n      const res: any = await cloudinary.search\n        .expression(expression)\n        .with_field('tags')\n        .with_field('bytes')\n        .with_field('context')\n        .with_field('folder')\n        .max_results(100)\n        .next_cursor(next_cursor)\n        .execute();\n\n      resources.push(...(res.resources || []));\n      next_cursor = res.next_cursor;\n    } while (next_cursor);\n\n    // 2) Get existing user's cloudinary_public_id list to avoid duplicates\n    const { data: existingRows, error: exErr } = await supabase\n      .from('assets')\n      .select('cloudinary_public_id')\n      .eq('user_id', userId);\n    if (exErr) throw exErr;\n\n    const existingSet = new Set<string>((existingRows || []).map(r => r.cloudinary_public_id).filter(Boolean));\n\n    // 3) Prepare rows for insert (only missing)\n    const rows = resources\n      .filter(r => !existingSet.has(r.public_id))\n      .map(r => ({\n        user_id: userId,\n        cloudinary_public_id: r.public_id as string,\n        media_type: (r.resource_type === 'video' ? 'video' : 'image') as 'image' | 'video',\n        status: 'ready' as const,\n        is_public: Array.isArray(r.tags) ? r.tags.includes('public') : false,\n        allow_remix: (r.context?.custom?.allow_remix === 'true') || false,\n        published_at: Array.isArray(r.tags) && r.tags.includes('public') ? (r.created_at as string) : null,\n        source_asset_id: null,\n        preset_key: r.context?.custom?.preset_key || null,\n        prompt: null,\n        created_at: r.created_at as string,\n        updated_at: new Date().toISOString(),\n      }));\n\n    let inserted = 0;\n    if (!dryRun && rows.length) {\n      const { error: insErr } = await supabase.from('assets').insert(rows);\n      if (insErr) throw insErr;\n      inserted = rows.length;\n    }\n\n    // 4) Ensure user and mega tags are attached (optional but useful)\n    let retagged = 0;\n    if (!dryRun && resources.length) {\n      const publicIds = resources.map(r => r.public_id as string);\n      const batches = chunk(publicIds, 80);\n      for (const ids of batches) {\n        await cloudinary.uploader.add_tag(`user:${userId}`, ids);\n        await cloudinary.uploader.add_tag(MEGA_TAG, ids);\n        retagged += ids.length;\n      }\n    }\n\n    return {\n      statusCode: 200,\n      body: JSON.stringify({\n        ok: true,\n        userId,\n        foundInCloudinary: resources.length,\n        inserted,\n        retagged,\n        dryRun,\n        expression,\n      }),\n    };\n  } catch (err: any) {\n    return { statusCode: 500, body: JSON.stringify({ ok: false, error: err.message, stack: err.stack }) };\n  }\n};\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AACA,yBAA6B;AAC7B,wBAAiC;AAEjC,IAAM,eAAe,QAAQ,IAAI;AACjC,IAAM,4BAA4B,QAAQ,IAAI;AAC9C,IAAM,WAAW,QAAQ,IAAI,uBAAuB;AAEpD,kBAAAA,GAAW,OAAO;AAAA,EAChB,YAAY,QAAQ,IAAI;AAAA,EACxB,SAAS,QAAQ,IAAI;AAAA,EACrB,YAAY,QAAQ,IAAI;AAAA,EACxB,QAAQ;AACV,CAAC;AAED,IAAM,eAAW,iCAAa,cAAc,yBAAyB;AASrE,SAAS,MAAS,KAAU,IAAI,KAAK;AACnC,QAAM,MAAa,CAAC;AACpB,WAAS,IAAI,GAAG,IAAI,IAAI,QAAQ,KAAK,EAAG,KAAI,KAAK,IAAI,MAAM,GAAG,IAAI,CAAC,CAAC;AACpE,SAAO;AACT;AAEO,IAAM,UAAmB,OAAO,UAAU;AAC/C,MAAI;AACF,QAAI,MAAM,eAAe,OAAQ,QAAO,EAAE,YAAY,KAAK,MAAM,qBAAqB;AAEtF,UAAM,OAAO,KAAK,MAAM,MAAM,QAAQ,IAAI;AAC1C,UAAM,EAAE,QAAQ,SAAS,OAAO,iBAAiB,CAAC,GAAG,cAAc,CAAC,EAAE,IAAI;AAC1E,QAAI,CAAC,OAAQ,QAAO,EAAE,YAAY,KAAK,MAAM,KAAK,UAAU,EAAE,IAAI,OAAO,OAAO,kBAAkB,CAAC,EAAE;AAGrG,UAAM,cAAwB;AAAA,MAC5B,0BAA0B,MAAM;AAAA,MAChC,cAAc,MAAM;AAAA,MACpB,GAAG,eAAe,IAAI,OAAK,WAAW,CAAC,GAAG;AAAA,MAC1C,GAAG,YAAY,IAAI,OAAK,SAAS,CAAC,GAAG;AAAA,IACvC;AACA,UAAM,aAAa,YAAY,KAAK,MAAM;AAE1C,QAAI,cAAkC;AACtC,UAAM,YAAmB,CAAC;AAE1B,OAAG;AACD,YAAM,MAAW,MAAM,kBAAAA,GAAW,OAC/B,WAAW,UAAU,EACrB,WAAW,MAAM,EACjB,WAAW,OAAO,EAClB,WAAW,SAAS,EACpB,WAAW,QAAQ,EACnB,YAAY,GAAG,EACf,YAAY,WAAW,EACvB,QAAQ;AAEX,gBAAU,KAAK,GAAI,IAAI,aAAa,CAAC,CAAE;AACvC,oBAAc,IAAI;AAAA,IACpB,SAAS;AAGT,UAAM,EAAE,MAAM,cAAc,OAAO,MAAM,IAAI,MAAM,SAChD,KAAK,QAAQ,EACb,OAAO,sBAAsB,EAC7B,GAAG,WAAW,MAAM;AACvB,QAAI,MAAO,OAAM;AAEjB,UAAM,cAAc,IAAI,KAAa,gBAAgB,CAAC,GAAG,IAAI,OAAK,EAAE,oBAAoB,EAAE,OAAO,OAAO,CAAC;AAGzG,UAAM,OAAO,UACV,OAAO,OAAK,CAAC,YAAY,IAAI,EAAE,SAAS,CAAC,EACzC,IAAI,QAAM;AAAA,MACT,SAAS;AAAA,MACT,sBAAsB,EAAE;AAAA,MACxB,YAAa,EAAE,kBAAkB,UAAU,UAAU;AAAA,MACrD,QAAQ;AAAA,MACR,WAAW,MAAM,QAAQ,EAAE,IAAI,IAAI,EAAE,KAAK,SAAS,QAAQ,IAAI;AAAA,MAC/D,aAAc,EAAE,SAAS,QAAQ,gBAAgB,UAAW;AAAA,MAC5D,cAAc,MAAM,QAAQ,EAAE,IAAI,KAAK,EAAE,KAAK,SAAS,QAAQ,IAAK,EAAE,aAAwB;AAAA,MAC9F,iBAAiB;AAAA,MACjB,YAAY,EAAE,SAAS,QAAQ,cAAc;AAAA,MAC7C,QAAQ;AAAA,MACR,YAAY,EAAE;AAAA,MACd,aAAY,oBAAI,KAAK,GAAE,YAAY;AAAA,IACrC,EAAE;AAEJ,QAAI,WAAW;AACf,QAAI,CAAC,UAAU,KAAK,QAAQ;AAC1B,YAAM,EAAE,OAAO,OAAO,IAAI,MAAM,SAAS,KAAK,QAAQ,EAAE,OAAO,IAAI;AACnE,UAAI,OAAQ,OAAM;AAClB,iBAAW,KAAK;AAAA,IAClB;AAGA,QAAI,WAAW;AACf,QAAI,CAAC,UAAU,UAAU,QAAQ;AAC/B,YAAM,YAAY,UAAU,IAAI,OAAK,EAAE,SAAmB;AAC1D,YAAM,UAAU,MAAM,WAAW,EAAE;AACnC,iBAAW,OAAO,SAAS;AACzB,cAAM,kBAAAA,GAAW,SAAS,QAAQ,QAAQ,MAAM,IAAI,GAAG;AACvD,cAAM,kBAAAA,GAAW,SAAS,QAAQ,UAAU,GAAG;AAC/C,oBAAY,IAAI;AAAA,MAClB;AAAA,IACF;AAEA,WAAO;AAAA,MACL,YAAY;AAAA,MACZ,MAAM,KAAK,UAAU;AAAA,QACnB,IAAI;AAAA,QACJ;AAAA,QACA,mBAAmB,UAAU;AAAA,QAC7B;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF,CAAC;AAAA,IACH;AAAA,EACF,SAAS,KAAU;AACjB,WAAO,EAAE,YAAY,KAAK,MAAM,KAAK,UAAU,EAAE,IAAI,OAAO,OAAO,IAAI,SAAS,OAAO,IAAI,MAAM,CAAC,EAAE;AAAA,EACtG;AACF;",
  "names": ["cloudinary"]
}
