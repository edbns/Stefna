{
  "version": 3,
  "sources": ["../../../../../../Users/sennie/Desktop/Stefna-main/netlify/functions/cloudinary-sign.js"],
  "sourceRoot": "/var/folders/3j/nmp5dkpd4tv8j0yq8f2ln8780000gn/T/tmp-42344-FXrf6PhPyph1",
  "sourcesContent": ["const { v2: cloudinary } = require(\"cloudinary\");\n\n// Configure Cloudinary\ncloudinary.config({\n  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,\n  api_key:    process.env.CLOUDINARY_API_KEY,\n  api_secret: process.env.CLOUDINARY_API_SECRET,\n  secure: true,\n});\n\nexports.handler = async (event) => {\n  try {\n    if (event.httpMethod !== \"POST\") {\n      return { statusCode: 405, body: \"Method Not Allowed\" };\n    }\n\n    // Check Cloudinary environment variables\n    const cloudName = process.env.CLOUDINARY_CLOUD_NAME;\n    const apiKey = process.env.CLOUDINARY_API_KEY;\n    const apiSecret = process.env.CLOUDINARY_API_SECRET;\n    \n    if (!cloudName || !apiKey || !apiSecret) {\n      console.error('\u274C Cloudinary env missing:', { \n        hasCloudName: !!cloudName, \n        hasKey: !!apiKey, \n        hasSecret: !!apiSecret \n      });\n      return { \n        statusCode: 500, \n        body: `sign_failed: Cloudinary environment not configured` \n      };\n    }\n\n    // Always sign only what you'll send from the client\n    const timestamp = Math.floor(Date.now() / 1000);\n    const folder = 'users'; // optional, if you actually use it\n\n    const paramsToSign = { timestamp, folder }; // keep minimal & consistent\n    const signature = cloudinary.utils.api_sign_request(paramsToSign, apiSecret);\n\n    return {\n      statusCode: 200,\n      headers: { \"Content-Type\": \"application/json\" },\n      body: JSON.stringify({\n        ok: true,\n        cloudName,\n        apiKey,\n        timestamp,\n        folder,\n        signature,\n        // snake_case variants for existing client helpers\n        cloud_name: cloudName,\n        api_key: apiKey,\n      }),\n    };\n  } catch (e) {\n    console.error(\"cloudinary-sign error:\", e);\n    // Return TEXT on error so the client can parse gracefully\n    return { \n      statusCode: 500, \n      body: `sign_failed: ${e?.message ?? 'unknown'}` \n    };\n  }\n};\n"],
  "mappings": ";;;AAAA,IAAM,EAAE,IAAI,WAAW,IAAI,QAAQ,YAAY;AAG/C,WAAW,OAAO;AAAA,EAChB,YAAY,QAAQ,IAAI;AAAA,EACxB,SAAY,QAAQ,IAAI;AAAA,EACxB,YAAY,QAAQ,IAAI;AAAA,EACxB,QAAQ;AACV,CAAC;AAED,QAAQ,UAAU,OAAO,UAAU;AACjC,MAAI;AACF,QAAI,MAAM,eAAe,QAAQ;AAC/B,aAAO,EAAE,YAAY,KAAK,MAAM,qBAAqB;AAAA,IACvD;AAGA,UAAM,YAAY,QAAQ,IAAI;AAC9B,UAAM,SAAS,QAAQ,IAAI;AAC3B,UAAM,YAAY,QAAQ,IAAI;AAE9B,QAAI,CAAC,aAAa,CAAC,UAAU,CAAC,WAAW;AACvC,cAAQ,MAAM,kCAA6B;AAAA,QACzC,cAAc,CAAC,CAAC;AAAA,QAChB,QAAQ,CAAC,CAAC;AAAA,QACV,WAAW,CAAC,CAAC;AAAA,MACf,CAAC;AACD,aAAO;AAAA,QACL,YAAY;AAAA,QACZ,MAAM;AAAA,MACR;AAAA,IACF;AAGA,UAAM,YAAY,KAAK,MAAM,KAAK,IAAI,IAAI,GAAI;AAC9C,UAAM,SAAS;AAEf,UAAM,eAAe,EAAE,WAAW,OAAO;AACzC,UAAM,YAAY,WAAW,MAAM,iBAAiB,cAAc,SAAS;AAE3E,WAAO;AAAA,MACL,YAAY;AAAA,MACZ,SAAS,EAAE,gBAAgB,mBAAmB;AAAA,MAC9C,MAAM,KAAK,UAAU;AAAA,QACnB,IAAI;AAAA,QACJ;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA;AAAA,QAEA,YAAY;AAAA,QACZ,SAAS;AAAA,MACX,CAAC;AAAA,IACH;AAAA,EACF,SAAS,GAAG;AACV,YAAQ,MAAM,0BAA0B,CAAC;AAEzC,WAAO;AAAA,MACL,YAAY;AAAA,MACZ,MAAM,gBAAgB,GAAG,WAAW,SAAS;AAAA,IAC/C;AAAA,EACF;AACF;",
  "names": []
}
